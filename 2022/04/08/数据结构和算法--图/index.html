<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构和算法---图（C++） | Eren的博客</title><meta name="keywords" content="博客, Eren"><meta name="author" content="Eren"><meta name="copyright" content="Eren"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="图结构以及对应算法   最近博主在学习数据结构和算法，主要的学习资料有b站上浙江大学课程数据结构和算法以及《大话数据结构》，这两个用来入门比较不错，但他们都是用c语言来实现，因此博主使用c++来实现图这一复杂结构以及对应的算法。存储结构使用了邻接矩阵、邻接表以及边集数组，分别实现了最小生成树、最短路径以及有向无环图三种应用，其中最小生成树使用了Prim算法、Kruskal算法，最短路径使用了Di">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构和算法---图（C++）">
<meta property="og:url" content="https://eren-only.github.io/2022/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95--%E5%9B%BE/index.html">
<meta property="og:site_name" content="Eren的博客">
<meta property="og:description" content="图结构以及对应算法   最近博主在学习数据结构和算法，主要的学习资料有b站上浙江大学课程数据结构和算法以及《大话数据结构》，这两个用来入门比较不错，但他们都是用c语言来实现，因此博主使用c++来实现图这一复杂结构以及对应的算法。存储结构使用了邻接矩阵、邻接表以及边集数组，分别实现了最小生成树、最短路径以及有向无环图三种应用，其中最小生成树使用了Prim算法、Kruskal算法，最短路径使用了Di">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-04-07T16:00:00.000Z">
<meta property="article:modified_time" content="2022-04-08T14:18:22.312Z">
<meta property="article:author" content="Eren">
<meta property="article:tag" content="博客, Eren">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://eren-only.github.io/2022/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95--%E5%9B%BE/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构和算法---图（C++）',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-04-08 22:18:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/yao.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Eren的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构和算法---图（C++）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-07T16:00:00.000Z" title="发表于 2022-04-08 00:00:00">2022-04-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-08T14:18:22.312Z" title="更新于 2022-04-08 22:18:22">2022-04-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构和算法---图（C++）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 align="center"> 图结构以及对应算法

<hr>
<h5 id="最近博主在学习数据结构和算法，主要的学习资料有b站上浙江大学课程数据结构和算法以及《大话数据结构》，这两个用来入门比较不错，但他们都是用c语言来实现，因此博主使用c-来实现图这一复杂结构以及对应的算法。存储结构使用了邻接矩阵、邻接表以及边集数组，分别实现了最小生成树、最短路径以及有向无环图三种应用，其中最小生成树使用了Prim算法、Kruskal算法，最短路径使用了Dijkstra算法、Floyd算法，有向无环图使用了拓扑排序以及关键路径的两种应用。以下是代码："><a href="#最近博主在学习数据结构和算法，主要的学习资料有b站上浙江大学课程数据结构和算法以及《大话数据结构》，这两个用来入门比较不错，但他们都是用c语言来实现，因此博主使用c-来实现图这一复杂结构以及对应的算法。存储结构使用了邻接矩阵、邻接表以及边集数组，分别实现了最小生成树、最短路径以及有向无环图三种应用，其中最小生成树使用了Prim算法、Kruskal算法，最短路径使用了Dijkstra算法、Floyd算法，有向无环图使用了拓扑排序以及关键路径的两种应用。以下是代码：" class="headerlink" title="最近博主在学习数据结构和算法，主要的学习资料有b站上浙江大学课程数据结构和算法以及《大话数据结构》，这两个用来入门比较不错，但他们都是用c语言来实现，因此博主使用c++来实现图这一复杂结构以及对应的算法。存储结构使用了邻接矩阵、邻接表以及边集数组，分别实现了最小生成树、最短路径以及有向无环图三种应用，其中最小生成树使用了Prim算法、Kruskal算法，最短路径使用了Dijkstra算法、Floyd算法，有向无环图使用了拓扑排序以及关键路径的两种应用。以下是代码："></a><strong>最近博主在学习数据结构和算法，主要的学习资料有b站上浙江大学课程<a href="%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1JW411i731?p=100)">数据结构和算法</a>以及《大话数据结构》，这两个用来入门比较不错，但他们都是用c语言来实现，因此博主使用c++来实现图这一复杂结构以及对应的算法。存储结构使用了邻接矩阵、邻接表以及边集数组，分别实现了最小生成树、最短路径以及有向无环图三种应用，其中最小生成树使用了Prim算法、Kruskal算法，最短路径使用了Dijkstra算法、Floyd算法，有向无环图使用了拓扑排序以及关键路径的两种应用。以下是代码：</strong></h5><p><strong>graph的头文件：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxVertex = <span class="number">14</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>* <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> m_Data;</span><br><span class="line">	<span class="keyword">bool</span> m_visited;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v1, v2;</span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_Nv;<span class="comment">//节点</span></span><br><span class="line">	<span class="keyword">int</span> m_Ne;<span class="comment">//边数</span></span><br><span class="line">	<span class="keyword">int</span> G[MaxVertex][MaxVertex];</span><br><span class="line">	Node* pNodeArray;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MGraph</span>(<span class="keyword">int</span> VertexNum);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2,<span class="keyword">int</span> weight)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InputData</span><span class="params">(<span class="keyword">int</span> Vertex,<span class="keyword">int</span> data)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ShowWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MinTree_Prim</span><span class="params">(<span class="keyword">int</span> parent[MaxVertex])</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MinTree_Kruskal</span><span class="params">(<span class="keyword">int</span> parent[MaxVertex])</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> Vertex1,<span class="keyword">int</span> Vertex2)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(<span class="keyword">int</span> Vertex1, <span class="keyword">int</span> Vertex2)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetNodeData</span><span class="params">(<span class="keyword">int</span> Vertex)</span> </span>;</span><br><span class="line">	~<span class="built_in">MGraph</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> m_CurNode;</span><br><span class="line">	<span class="keyword">int</span> m_Weight;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> m_Data;</span><br><span class="line">	<span class="keyword">int</span> m_in;</span><br><span class="line">	<span class="keyword">bool</span> m_Visit;</span><br><span class="line">	<span class="keyword">bool</span> m_Kusal;</span><br><span class="line">	<span class="keyword">int</span> m_Earliest;</span><br><span class="line">	<span class="keyword">int</span> m_Latest;</span><br><span class="line">	EdgeNode* FirstEdge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeMaxtrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> m_Begin;</span><br><span class="line">	<span class="keyword">int</span> m_End;</span><br><span class="line">	<span class="keyword">int</span> m_Weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ALGraph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_Nv;<span class="comment">//节点</span></span><br><span class="line">	<span class="keyword">int</span> m_Ne;<span class="comment">//边数</span></span><br><span class="line">	VertexNode AdjList[MaxVertex];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ALGraph</span>(<span class="keyword">int</span> VertexNum);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InputData</span><span class="params">(<span class="keyword">int</span> Vertex, <span class="keyword">int</span> data)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ShowWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MinTree_Prim</span><span class="params">(<span class="keyword">int</span> parent[MaxVertex])</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MinTree_Kruskal</span><span class="params">(<span class="keyword">int</span> parent[MaxVertex])</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetNodeData</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetInNode</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">TopoSort</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">TopoSortUseCriticalPath</span><span class="params">(stack&lt;<span class="keyword">int</span>&gt; &amp; s2)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CriticalPath</span><span class="params">()</span></span>;</span><br><span class="line">	~<span class="built_in">ALGraph</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(EdgeMaxtrix E1, EdgeMaxtrix E2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span>* parent, <span class="keyword">int</span> f)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>graph的实现文件：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;graph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mINFINITY = <span class="number">655550</span>;</span><br><span class="line"></span><br><span class="line">MGraph::<span class="built_in">MGraph</span>(<span class="keyword">int</span> VertexNum)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> v, w;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Nv = VertexNum;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Ne = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; VertexNum; v++)</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; VertexNum; w++)</span><br><span class="line">			<span class="keyword">if</span> (v == w)</span><br><span class="line">			&#123;</span><br><span class="line">				G[v][w] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				G[v][w] = mINFINITY;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;pNodeArray = <span class="keyword">new</span> Node[VertexNum];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VertexNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pNodeArray[i].m_visited = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::InsertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	G[v1][v2] = weight;</span><br><span class="line">	G[v2][v1] = weight;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Ne++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::InputData</span><span class="params">(<span class="keyword">int</span> Vertex, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pNodeArray[Vertex].m_Data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::ShowWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;G[v1][v2] != mINFINITY)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; 相连 &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; G[v1][v2] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有相连&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::DFS</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = Vertex;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pNodeArray[Vertex].m_visited = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;pNodeArray[Vertex].m_Data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val != i &amp;&amp; G[i][val] != mINFINITY )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pNodeArray[i].m_visited == <span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">DFS</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::BFS</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">int</span> val = Vertex;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pNodeArray[Vertex].m_visited = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;pNodeArray[Vertex].m_Data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	q1.<span class="built_in">push</span>(Vertex);</span><br><span class="line">	<span class="keyword">while</span> (!q1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		temp = q1.<span class="built_in">front</span>();</span><br><span class="line">		q1.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (temp != i &amp;&amp; G[temp][i] != mINFINITY)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pNodeArray[i].m_visited == <span class="literal">false</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">this</span>-&gt;pNodeArray[i].m_visited = <span class="literal">true</span>;</span><br><span class="line">					cout &lt;&lt; <span class="keyword">this</span>-&gt;pNodeArray[i].m_Data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">					q1.<span class="built_in">push</span>(i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::MinTree_Prim</span><span class="params">(<span class="keyword">int</span> parent[MaxVertex])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lowcost[MaxVertex];</span><br><span class="line">	<span class="comment">/*int parent[MaxVertex];*/</span></span><br><span class="line">	</span><br><span class="line">	lowcost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	parent[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;m_Nv; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		lowcost[j] = <span class="keyword">this</span>-&gt;G[<span class="number">0</span>][j];</span><br><span class="line">		parent[j] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> min = mINFINITY;</span><br><span class="line">		<span class="keyword">int</span> temp;</span><br><span class="line">		<span class="comment">//找到lowcost除了0之外的最小值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (lowcost[i] != <span class="number">0</span> &amp;&amp; lowcost[i] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = lowcost[i];</span><br><span class="line">				temp = i;</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">		<span class="keyword">if</span> (min == mINFINITY)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		lowcost[temp] = <span class="number">0</span>;</span><br><span class="line">		cout &lt;&lt; parent[temp] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; temp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (lowcost[i] != <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>-&gt;G[temp][i] &lt; lowcost[i])</span><br><span class="line">			&#123;</span><br><span class="line">				lowcost[i] = <span class="keyword">this</span>-&gt;G[temp][i];</span><br><span class="line">				parent[i] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::MinTree_Kruskal</span><span class="params">(<span class="keyword">int</span> parent[MaxVertex])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt; EdgeMaxtrix&gt; <span class="title">Edge</span><span class="params">(<span class="keyword">this</span>-&gt;m_Ne)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;m_Nv; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;G[i][j] != <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>-&gt;G[i][j] &lt; mINFINITY)</span><br><span class="line">			&#123;</span><br><span class="line">				Edge[k].m_Begin = i;</span><br><span class="line">				Edge[k].m_End = j;</span><br><span class="line">				Edge[k].m_Weight = <span class="keyword">this</span>-&gt;G[i][j];</span><br><span class="line">				k++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(Edge.<span class="built_in">begin</span>(), Edge.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">		parent[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Ne; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		n = <span class="built_in">Find</span>(parent, Edge[i].m_Begin);</span><br><span class="line">		m = <span class="built_in">Find</span>(parent, Edge[i].m_End);</span><br><span class="line">		<span class="keyword">if</span> (n != m)</span><br><span class="line">		&#123;</span><br><span class="line">			parent[n] = m;</span><br><span class="line">			cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Edge[i].m_Weight &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::Dijkstra</span><span class="params">(<span class="keyword">int</span> Vertex1, <span class="keyword">int</span> Vertex2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Patharc[MaxVertex];</span><br><span class="line">	<span class="keyword">int</span> ShortPathWeight[MaxVertex];</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">final</span>[MaxVertex];</span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line">	<span class="keyword">int</span> j,k = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//初始化Parent和ShortPathWeight</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">final</span>[i] = <span class="number">0</span>;</span><br><span class="line">		Patharc[i] = <span class="number">-1</span>;</span><br><span class="line">		ShortPathWeight[i] = <span class="keyword">this</span>-&gt;G[Vertex1][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span>[Vertex1] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		min = mINFINITY;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;m_Nv; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[j] &amp;&amp; ShortPathWeight[j] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = ShortPathWeight[j];</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span>[k] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[i] &amp;&amp; (min + <span class="keyword">this</span>-&gt;G[k][i] &lt; ShortPathWeight[i]))</span><br><span class="line">			&#123;</span><br><span class="line">				ShortPathWeight[i] = min + <span class="keyword">this</span>-&gt;G[k][i];</span><br><span class="line">				Patharc[i] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最短路径为： &quot;</span>;</span><br><span class="line">	Patharc[Vertex1] = <span class="number">-2</span>;</span><br><span class="line">	<span class="keyword">int</span> temp = Vertex2;</span><br><span class="line">	cout &lt;&lt; Vertex2 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (Patharc[temp] != <span class="number">-2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Patharc[temp] &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = Patharc[temp];</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Patharc[temp] == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = Vertex1;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; temp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;权值最小为： &quot;</span>;</span><br><span class="line">	cout &lt;&lt; ShortPathWeight[Vertex2] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::Floyd</span><span class="params">(<span class="keyword">int</span> Vertex1, <span class="keyword">int</span> Vertex2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Patharc[MaxVertex][MaxVertex];</span><br><span class="line">	<span class="keyword">int</span> ShortPath[MaxVertex][MaxVertex];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;m_Nv; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			ShortPath[i][j] = <span class="keyword">this</span>-&gt;G[i][j];</span><br><span class="line">			Patharc[i][j] = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="keyword">this</span>-&gt;m_Nv; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;m_Nv; j++)</span><br><span class="line">				<span class="keyword">if</span> (ShortPath[i][j] &gt; ShortPath[i][k] + ShortPath[k][j])</span><br><span class="line">				&#123;</span><br><span class="line">					ShortPath[i][j] = ShortPath[i][k] + ShortPath[k][j];</span><br><span class="line">					Patharc[i][j] = Patharc[i][k];</span><br><span class="line">				&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//for (int i = 0; i &lt; this-&gt;m_Nv; i++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	for (int j = 0; j &lt; this-&gt;m_Nv; j++)</span></span><br><span class="line">	<span class="comment">//	&#123;</span></span><br><span class="line">	<span class="comment">//		cout &lt;&lt; ShortPath[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最短路径为：&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> f = Vertex1;</span><br><span class="line">	<span class="keyword">while</span> (f != Vertex2)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; f &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		f = Patharc[f][Vertex2];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; f &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最小权值为：&quot;</span> &lt;&lt; ShortPath[Vertex1][Vertex2] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph::GetNodeData</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;pNodeArray[Vertex].m_Data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MGraph::~<span class="built_in">MGraph</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pNodeArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALGraph::<span class="built_in">ALGraph</span>(<span class="keyword">int</span> VertexNum)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Nv = VertexNum;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Ne = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VertexNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;AdjList[i].FirstEdge = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;AdjList[i].m_Visit = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;AdjList[i].m_Kusal = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;AdjList[i].m_in = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;AdjList[i].m_Earliest = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;AdjList[i].m_Latest = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALGraph::InsertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EdgeNode* e = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">	e-&gt;m_Weight = weight;</span><br><span class="line">	e-&gt;m_CurNode = v2;</span><br><span class="line">	e-&gt;next = <span class="keyword">this</span>-&gt;AdjList[v1].FirstEdge;</span><br><span class="line">	<span class="keyword">this</span>-&gt;AdjList[v1].FirstEdge = e;</span><br><span class="line">	<span class="keyword">this</span>-&gt;AdjList[v2].m_in = <span class="keyword">this</span>-&gt;AdjList[v2].m_in + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//EdgeNode* e1 = new EdgeNode;</span></span><br><span class="line">	<span class="comment">//e1-&gt;m_Weight = weight;</span></span><br><span class="line">	<span class="comment">//e1-&gt;m_CurNode = v1;</span></span><br><span class="line">	<span class="comment">//e1-&gt;next = this-&gt;AdjList[v2].FirstEdge;</span></span><br><span class="line">	<span class="comment">//this-&gt;AdjList[v2].FirstEdge = e1;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//this-&gt;m_Ne++;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALGraph::InputData</span><span class="params">(<span class="keyword">int</span> Vertex, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AdjList[Vertex].m_Data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALGraph::ShowWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EdgeNode* e = <span class="keyword">this</span>-&gt;AdjList[v1].FirstEdge;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (e != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (e-&gt;m_CurNode == v2)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; 相连 &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; e-&gt;m_Weight &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		e = e-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;没有相连&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALGraph::DFS</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EdgeNode* e = <span class="keyword">this</span>-&gt;AdjList[Vertex].FirstEdge;</span><br><span class="line">	<span class="keyword">int</span> val = Vertex;</span><br><span class="line">	<span class="keyword">this</span>-&gt;AdjList[Vertex].m_Visit = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;AdjList[Vertex].m_Data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(e != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;AdjList[e-&gt;m_CurNode].m_Visit == <span class="literal">false</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">DFS</span>(e-&gt;m_CurNode);</span><br><span class="line">		&#125;</span><br><span class="line">		e = e-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALGraph::BFS</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EdgeNode* e ;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">int</span> val = Vertex;</span><br><span class="line">	<span class="keyword">this</span>-&gt;AdjList[Vertex].m_Visit = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;AdjList[Vertex].m_Data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	q1.<span class="built_in">push</span>(Vertex);</span><br><span class="line">	<span class="keyword">while</span> (!q1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		temp = q1.<span class="built_in">front</span>();</span><br><span class="line">		q1.<span class="built_in">pop</span>();</span><br><span class="line">		e = <span class="keyword">this</span>-&gt;AdjList[temp].FirstEdge;</span><br><span class="line">		<span class="keyword">while</span> (e != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;AdjList[e-&gt;m_CurNode].m_Visit == <span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">this</span>-&gt;AdjList[e-&gt;m_CurNode].m_Visit = <span class="literal">true</span>;</span><br><span class="line">				cout &lt;&lt; <span class="keyword">this</span>-&gt;AdjList[e-&gt;m_CurNode].m_Data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">					q1.<span class="built_in">push</span>(e-&gt;m_CurNode);</span><br><span class="line">			&#125;</span><br><span class="line">			e = e-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALGraph::MinTree_Prim</span><span class="params">(<span class="keyword">int</span> parent[MaxVertex])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lowcost[MaxVertex];</span><br><span class="line">	lowcost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	parent[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>-&gt;m_Nv; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		lowcost[j] = mINFINITY;</span><br><span class="line">		parent[j] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	EdgeNode* e = <span class="keyword">this</span>-&gt;AdjList[<span class="number">0</span>].FirstEdge;</span><br><span class="line">	<span class="keyword">while</span> (e != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		lowcost[e-&gt;m_CurNode] = e-&gt;m_Weight;</span><br><span class="line">		e = e-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> min = mINFINITY;</span><br><span class="line">		<span class="keyword">int</span> temp;</span><br><span class="line">		<span class="comment">//找到lowcost除了0之外的最小值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (lowcost[i] != <span class="number">0</span> &amp;&amp; lowcost[i] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = lowcost[i];</span><br><span class="line">				temp = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (min == mINFINITY)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		lowcost[temp] = <span class="number">0</span>;</span><br><span class="line">		cout &lt;&lt; parent[temp] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; temp &lt;&lt; endl;</span><br><span class="line">		EdgeNode* e1 = <span class="keyword">this</span>-&gt;AdjList[temp].FirstEdge;</span><br><span class="line">		<span class="keyword">while</span> (e1 != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (e1-&gt;m_Weight &lt; lowcost[e1-&gt;m_CurNode])</span><br><span class="line">			&#123;</span><br><span class="line">				lowcost[e1-&gt;m_CurNode] = e1-&gt;m_Weight;</span><br><span class="line">				parent[e1-&gt;m_CurNode] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			e1 = e1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALGraph::MinTree_Kruskal</span><span class="params">(<span class="keyword">int</span> parent[MaxVertex])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt; EdgeMaxtrix&gt; <span class="title">Edge</span><span class="params">(<span class="keyword">this</span>-&gt;m_Ne)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		EdgeNode* e = <span class="keyword">this</span>-&gt;AdjList[i].FirstEdge;</span><br><span class="line">		<span class="keyword">this</span>-&gt;AdjList[i].m_Kusal = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (e != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;AdjList[e-&gt;m_CurNode].m_Kusal == <span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Edge[k].m_Begin = i;</span><br><span class="line">				Edge[k].m_End = e-&gt;m_CurNode;</span><br><span class="line">				Edge[k].m_Weight = e-&gt;m_Weight;</span><br><span class="line">				k++;	</span><br><span class="line">			&#125;</span><br><span class="line">			e = e-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(Edge.<span class="built_in">begin</span>(), Edge.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">		parent[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Ne; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		n = <span class="built_in">Find</span>(parent, Edge[i].m_Begin);</span><br><span class="line">		m = <span class="built_in">Find</span>(parent, Edge[i].m_End);</span><br><span class="line">		<span class="keyword">if</span> (n != m)</span><br><span class="line">		&#123;</span><br><span class="line">			parent[n] = m;</span><br><span class="line">			cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Edge[i].m_Weight &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALGraph::GetNodeData</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;AdjList[Vertex].m_Data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALGraph::GetInNode</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;AdjList[Vertex].m_in &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ALGraph::TopoSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp,count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	EdgeNode* e;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == <span class="keyword">this</span>-&gt;AdjList[i].m_in)</span><br><span class="line">			s.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		temp = s.<span class="built_in">top</span>();</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">		cout &lt;&lt; <span class="keyword">this</span>-&gt;AdjList[temp].m_Data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">for</span> (e = <span class="keyword">this</span>-&gt;AdjList[temp].FirstEdge; e != <span class="literal">nullptr</span>; e = e-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			k = e-&gt;m_CurNode;</span><br><span class="line">			<span class="keyword">this</span>-&gt;AdjList[k].m_in--;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="keyword">this</span>-&gt;AdjList[k].m_in)</span><br><span class="line">				s.<span class="built_in">push</span>(k);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count &lt; <span class="keyword">this</span>-&gt;m_Nv)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有环&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ALGraph::TopoSortUseCriticalPath</span><span class="params">(stack&lt;<span class="keyword">int</span>&gt;&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp, count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	EdgeNode* e;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == <span class="keyword">this</span>-&gt;AdjList[i].m_in)<span class="comment">//把度为0的节点压栈</span></span><br><span class="line">			s1.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		temp = s1.<span class="built_in">top</span>();</span><br><span class="line">		s1.<span class="built_in">pop</span>();</span><br><span class="line">		count++;</span><br><span class="line">		s2.<span class="built_in">push</span>(temp);</span><br><span class="line">		<span class="keyword">for</span> (e = <span class="keyword">this</span>-&gt;AdjList[temp].FirstEdge; e != <span class="literal">nullptr</span>; e = e-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			k = e-&gt;m_CurNode;</span><br><span class="line">			<span class="keyword">this</span>-&gt;AdjList[k].m_in--;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;AdjList[k].m_in)</span><br><span class="line">				s1.<span class="built_in">push</span>(k);</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;AdjList[temp].m_Earliest + e-&gt;m_Weight &gt; <span class="keyword">this</span>-&gt;AdjList[k].m_Earliest)</span><br><span class="line">				<span class="keyword">this</span>-&gt;AdjList[k].m_Earliest = <span class="keyword">this</span>-&gt;AdjList[temp].m_Earliest + e-&gt;m_Weight;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count &lt; <span class="keyword">this</span>-&gt;m_Nv)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有环&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALGraph::CriticalPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EdgeNode* Node;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">int</span> ete;</span><br><span class="line">	<span class="keyword">int</span> lte;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">TopoSortUseCriticalPath</span>(s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;AdjList[i].m_Latest = <span class="keyword">this</span>-&gt;AdjList[<span class="keyword">this</span>-&gt;m_Nv - <span class="number">1</span>].m_Earliest;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算latest time</span></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		temp = s.<span class="built_in">top</span>();</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (Node = <span class="keyword">this</span>-&gt;AdjList[temp].FirstEdge; Node != <span class="literal">nullptr</span>; Node = Node-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;AdjList[Node-&gt;m_CurNode].m_Latest - Node-&gt;m_Weight &lt; <span class="keyword">this</span>-&gt;AdjList[temp].m_Latest)</span><br><span class="line">				<span class="keyword">this</span>-&gt;AdjList[temp].m_Latest = <span class="keyword">this</span>-&gt;AdjList[Node-&gt;m_CurNode].m_Latest - Node-&gt;m_Weight;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;m_Nv; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (Node = <span class="keyword">this</span>-&gt;AdjList[j].FirstEdge; Node != <span class="literal">nullptr</span>; Node = Node-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			ete = <span class="keyword">this</span>-&gt;AdjList[j].m_Earliest;</span><br><span class="line">			lte = <span class="keyword">this</span>-&gt;AdjList[Node-&gt;m_CurNode].m_Latest - Node-&gt;m_Weight;</span><br><span class="line">			<span class="keyword">if</span> (ete == lte)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;m_Nv - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALGraph::~<span class="built_in">ALGraph</span>()</span><br><span class="line">&#123;</span><br><span class="line">	EdgeNode* e;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Nv; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		e = <span class="keyword">this</span>-&gt;AdjList[i].FirstEdge;</span><br><span class="line">		<span class="keyword">while</span> (e != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;AdjList[i].FirstEdge = <span class="keyword">this</span>-&gt;AdjList[i].FirstEdge-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> e;</span><br><span class="line">			e = <span class="keyword">this</span>-&gt;AdjList[i].FirstEdge;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(EdgeMaxtrix E1, EdgeMaxtrix E2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> E1.m_Weight &lt; E2.m_Weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span>* parent, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (parent[f] &gt; <span class="number">0</span>)</span><br><span class="line">		f = parent[f];</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>main文件</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;graph.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;yao.txt&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> parent[MaxVertex];</span><br><span class="line">	<span class="keyword">int</span> VertexNum,EdgeNum,data;</span><br><span class="line">	<span class="keyword">int</span> Vertex1, Vertex2, Weight;</span><br><span class="line">	ifs &gt;&gt; VertexNum &gt;&gt; EdgeNum;</span><br><span class="line"></span><br><span class="line">	<span class="function">ALGraph <span class="title">A1</span><span class="params">(VertexNum)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VertexNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ifs &gt;&gt; data;</span><br><span class="line">		A1.<span class="built_in">InputData</span>(i, data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; EdgeNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ifs &gt;&gt; Vertex1 &gt;&gt; Vertex2 &gt;&gt; Weight;</span><br><span class="line">		A1.<span class="built_in">InsertEdge</span>(Vertex1, Vertex2, Weight);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A1.<span class="built_in">CriticalPath</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Eren</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://eren-only.github.io/2022/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95--%E5%9B%BE/">https://eren-only.github.io/2022/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95--%E5%9B%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://eren-only.github.io" target="_blank">Eren的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/03/09/%E8%96%84%E8%86%9C%E9%BB%8F%E9%99%84%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%89%E9%99%90%E5%85%83%E6%96%B9%E6%B3%95/"><img class="next-cover" src="http://www.imech.cas.cn/xwdt/kydt/201909/W020190905572469035373.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">薄膜黏附问题的有限元方法</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTM4MS8zMTg0OA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/yao.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Eren</div><div class="author-info__description">可以转但只能转一点点</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text"> 图结构以及对应算法


最近博主在学习数据结构和算法，主要的学习资料有b站上浙江大学课程数据结构和算法以及《大话数据结构》，这两个用来入门比较不错，但他们都是用c语言来实现，因此博主使用c++来实现图这一复杂结构以及对应的算法。存储结构使用了邻接矩阵、邻接表以及边集数组，分别实现了最小生成树、最短路径以及有向无环图三种应用，其中最小生成树使用了Prim算法、Kruskal算法，最短路径使用了Dijkstra算法、Floyd算法，有向无环图使用了拓扑排序以及关键路径的两种应用。以下是代码：graph的头文件：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
#pragma once
#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;stack&gt;
using namespace std;
const int MaxVertex &#x3D; 14;
typedef struct ENode* Edge;


struct Node
{
	int m_Data;
	bool m_visited;
};

struct ENode
{
	int v1, v2;
	int weight;
};

class MGraph
{
private:
	int m_Nv;&#x2F;&#x2F;节点
	int m_Ne;&#x2F;&#x2F;边数
	int G[MaxVertex][MaxVertex];
	Node* pNodeArray;
public:
	MGraph(int VertexNum);
	void InsertEdge(int v1,int v2,int weight);
	void InputData(int Vertex,int data);
	void ShowWeight(int v1, int v2);
	void DFS(int Vertex);
	void BFS(int Vertex);
	void MinTree_Prim(int parent[MaxVertex]);
	void MinTree_Kruskal(int parent[MaxVertex]);
	void Dijkstra(int Vertex1,int Vertex2);
	void Floyd(int Vertex1, int Vertex2);
	void GetNodeData(int Vertex) ;
	~MGraph();
};


struct EdgeNode
{
	int m_CurNode;
	int m_Weight;
	struct EdgeNode* next;
};

struct VertexNode
{
	int m_Data;
	int m_in;
	bool m_Visit;
	bool m_Kusal;
	int m_Earliest;
	int m_Latest;
	EdgeNode* FirstEdge;
};


struct EdgeMaxtrix
{
	int m_Begin;
	int m_End;
	int m_Weight;
};


class ALGraph
{
private:
	int m_Nv;&#x2F;&#x2F;节点
	int m_Ne;&#x2F;&#x2F;边数
	VertexNode AdjList[MaxVertex];
public:
	ALGraph(int VertexNum);
	void InsertEdge(int v1, int v2, int weight);
	void InputData(int Vertex, int data);
	void ShowWeight(int v1, int v2);
	void DFS(int Vertex);
	void BFS(int Vertex);
	void MinTree_Prim(int parent[MaxVertex]);
	void MinTree_Kruskal(int parent[MaxVertex]);
	void Dijkstra();
	void GetNodeData(int Vertex);
	void GetInNode(int Vertex);
	bool TopoSort();
	bool TopoSortUseCriticalPath(stack&lt;int&gt; &amp; s2);
	void CriticalPath();
	~ALGraph();
};


bool compare(EdgeMaxtrix E1, EdgeMaxtrix E2);
int Find(int* parent, int f);




graph的实现文件：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
#include&lt;iostream&gt;
#include&quot;graph.h&quot;
#include&lt;fstream&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;stack&gt;
using namespace std;
const int mINFINITY &#x3D; 655550;

MGraph::MGraph(int VertexNum)
{
	int v, w;
	this-&gt;m_Nv &#x3D; VertexNum;
	this-&gt;m_Ne &#x3D; 0;
	for (v &#x3D; 0; v &lt; VertexNum; v++)
		for (w &#x3D; 0; w &lt; VertexNum; w++)
			if (v &#x3D;&#x3D; w)
			{
				G[v][w] &#x3D; 0;
			}
			else
			{
				G[v][w] &#x3D; mINFINITY;
			}

	this-&gt;pNodeArray &#x3D; new Node[VertexNum];
	for (int i &#x3D; 0; i &lt; VertexNum; i++)
	{
		this-&gt;pNodeArray[i].m_visited &#x3D; 0;
	}
}

void MGraph::InsertEdge(int v1, int v2, int weight)
{
	G[v1][v2] &#x3D; weight;
	G[v2][v1] &#x3D; weight;
	this-&gt;m_Ne++;
}


void MGraph::InputData(int Vertex, int data)
{
	pNodeArray[Vertex].m_Data &#x3D; data;
}

void MGraph::ShowWeight(int v1, int v2)
{
	if (this-&gt;G[v1][v2] !&#x3D; mINFINITY)
	{
		cout &lt;&lt; v1 &lt;&lt; &quot; 相连 &quot; &lt;&lt; v2 &lt;&lt; &quot;  &quot; &lt;&lt; G[v1][v2] &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;没有相连&quot; &lt;&lt; endl;
	}
}

void MGraph::DFS(int Vertex)
{
	int val &#x3D; Vertex;
	this-&gt;pNodeArray[Vertex].m_visited &#x3D; true;
	cout &lt;&lt; this-&gt;pNodeArray[Vertex].m_Data &lt;&lt; &quot; &quot;;
	for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
	{
		if (val !&#x3D; i &amp;&amp; G[i][val] !&#x3D; mINFINITY )
		{
			if (this-&gt;pNodeArray[i].m_visited &#x3D;&#x3D; false)
			{
				DFS(i);
			}
		}
	}
}

void MGraph::BFS(int Vertex)
{
	queue&lt;int&gt; q1;
	int temp;
	int val &#x3D; Vertex;
	this-&gt;pNodeArray[Vertex].m_visited &#x3D; true;
	cout &lt;&lt; this-&gt;pNodeArray[Vertex].m_Data &lt;&lt; &quot; &quot;;
	q1.push(Vertex);
	while (!q1.empty())
	{
		temp &#x3D; q1.front();
		q1.pop();
		for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
		{
			if (temp !&#x3D; i &amp;&amp; G[temp][i] !&#x3D; mINFINITY)
			{
				if (this-&gt;pNodeArray[i].m_visited &#x3D;&#x3D; false)
				{
					this-&gt;pNodeArray[i].m_visited &#x3D; true;
					cout &lt;&lt; this-&gt;pNodeArray[i].m_Data &lt;&lt; &quot; &quot;;
					q1.push(i);
				}
			}
		}
	}
}

void MGraph::MinTree_Prim(int parent[MaxVertex])
{
	int lowcost[MaxVertex];
	&#x2F;*int parent[MaxVertex];*&#x2F;
	
	lowcost[0] &#x3D; 0;
	parent[0] &#x3D; 0;
	for (int j &#x3D; 1; j &lt; this-&gt;m_Nv; j++)
	{
		lowcost[j] &#x3D; this-&gt;G[0][j];
		parent[j] &#x3D; 0;
	}
	while (1)
	{
		int min &#x3D; mINFINITY;
		int temp;
		&#x2F;&#x2F;找到lowcost除了0之外的最小值
		for (int i &#x3D; 1; i &lt; this-&gt;m_Nv; i++)
		{
			if (lowcost[i] !&#x3D; 0 &amp;&amp; lowcost[i] &lt; min)
			{
				min &#x3D; lowcost[i];
				temp &#x3D; i;
			}
    	}
		if (min &#x3D;&#x3D; mINFINITY)
			break;
		lowcost[temp] &#x3D; 0;
		cout &lt;&lt; parent[temp] &lt;&lt; &quot; &quot; &lt;&lt; temp &lt;&lt; endl;

		for (int i &#x3D; 1; i &lt; this-&gt;m_Nv; i++)
		{
			if (lowcost[i] !&#x3D; 0 &amp;&amp; this-&gt;G[temp][i] &lt; lowcost[i])
			{
				lowcost[i] &#x3D; this-&gt;G[temp][i];
				parent[i] &#x3D; temp;
			}
		}
	}
}

void MGraph::MinTree_Kruskal(int parent[MaxVertex])
{
	vector&lt; EdgeMaxtrix&gt; Edge(this-&gt;m_Ne);
	int k &#x3D; 0;
	int n, m;
	for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
	{
		for (int j &#x3D; i+1; j &lt; this-&gt;m_Nv; j++)
		{
			if (this-&gt;G[i][j] !&#x3D; 0 &amp;&amp; this-&gt;G[i][j] &lt; mINFINITY)
			{
				Edge[k].m_Begin &#x3D; i;
				Edge[k].m_End &#x3D; j;
				Edge[k].m_Weight &#x3D; this-&gt;G[i][j];
				k++;
			}
		}
	}

	sort(Edge.begin(), Edge.end(), compare);



	for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
		parent[i] &#x3D; 0;
	for (int i &#x3D; 0; i &lt; this-&gt;m_Ne; i++)
	{
		n &#x3D; Find(parent, Edge[i].m_Begin);
		m &#x3D; Find(parent, Edge[i].m_End);
		if (n !&#x3D; m)
		{
			parent[n] &#x3D; m;
			cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; Edge[i].m_Weight &lt;&lt; endl;
		}
	}

}

void MGraph::Dijkstra(int Vertex1, int Vertex2)
{
	int Patharc[MaxVertex];
	int ShortPathWeight[MaxVertex];
	int final[MaxVertex];
	int min;
	int j,k &#x3D; 0;
&#x2F;&#x2F;初始化Parent和ShortPathWeight
	for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
	{
		final[i] &#x3D; 0;
		Patharc[i] &#x3D; -1;
		ShortPathWeight[i] &#x3D; this-&gt;G[Vertex1][i];
	}
	final[Vertex1] &#x3D; 1;
	for (int i &#x3D; 1; i &lt; this-&gt;m_Nv; i++)
	{
		min &#x3D; mINFINITY;
		for (j &#x3D; 0; j &lt; this-&gt;m_Nv; j++)
		{
			if (!final[j] &amp;&amp; ShortPathWeight[j] &lt; min)
			{
				min &#x3D; ShortPathWeight[j];
				k &#x3D; j;
			}
		}

		final[k] &#x3D; 1;

		for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
		{
			if (!final[i] &amp;&amp; (min + this-&gt;G[k][i] &lt; ShortPathWeight[i]))
			{
				ShortPathWeight[i] &#x3D; min + this-&gt;G[k][i];
				Patharc[i] &#x3D; k;
			}
		}
	}
	
	cout &lt;&lt; &quot;最短路径为： &quot;;
	Patharc[Vertex1] &#x3D; -2;
	int temp &#x3D; Vertex2;
	cout &lt;&lt; Vertex2 &lt;&lt; &quot; &quot;;
	while (Patharc[temp] !&#x3D; -2)
	{
		if (Patharc[temp] &gt;&#x3D; 0)
		{
			temp &#x3D; Patharc[temp];
			
		}
		else if (Patharc[temp] &#x3D;&#x3D; -1)
		{
			temp &#x3D; Vertex1;
		}
		cout &lt;&lt; temp &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
	cout &lt;&lt; &quot;权值最小为： &quot;;
	cout &lt;&lt; ShortPathWeight[Vertex2] &lt;&lt; endl;
}

void MGraph::Floyd(int Vertex1, int Vertex2)
{
	int Patharc[MaxVertex][MaxVertex];
	int ShortPath[MaxVertex][MaxVertex];
	for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
	{
		for (int j &#x3D; 0; j &lt; this-&gt;m_Nv; j++)
		{
			ShortPath[i][j] &#x3D; this-&gt;G[i][j];
			Patharc[i][j] &#x3D; j;
		}
	}
	for (int k &#x3D; 0; k &lt; this-&gt;m_Nv; k++)
	{
		for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
			for (int j &#x3D; 0; j &lt; this-&gt;m_Nv; j++)
				if (ShortPath[i][j] &gt; ShortPath[i][k] + ShortPath[k][j])
				{
					ShortPath[i][j] &#x3D; ShortPath[i][k] + ShortPath[k][j];
					Patharc[i][j] &#x3D; Patharc[i][k];
				}
	}

	&#x2F;&#x2F;for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
	&#x2F;&#x2F;{
	&#x2F;&#x2F;	for (int j &#x3D; 0; j &lt; this-&gt;m_Nv; j++)
	&#x2F;&#x2F;	{
	&#x2F;&#x2F;		cout &lt;&lt; ShortPath[i][j] &lt;&lt; &quot; &quot;;
	&#x2F;&#x2F;	}
	&#x2F;&#x2F;	cout &lt;&lt; endl;
	&#x2F;&#x2F;}


	cout &lt;&lt; &quot;最短路径为：&quot;;
	int f &#x3D; Vertex1;
	while (f !&#x3D; Vertex2)
	{
		cout &lt;&lt; f &lt;&lt; &quot; &quot;;
		f &#x3D; Patharc[f][Vertex2];
	}
	cout &lt;&lt; f &lt;&lt; &quot; &quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;最小权值为：&quot; &lt;&lt; ShortPath[Vertex1][Vertex2] &lt;&lt; endl;
}

void MGraph::GetNodeData(int Vertex)
{
	cout &lt;&lt; this-&gt;pNodeArray[Vertex].m_Data &lt;&lt; &quot; &quot;;
}


MGraph::~MGraph()
{
	delete[] this-&gt;pNodeArray;
}



ALGraph::ALGraph(int VertexNum)
{
	this-&gt;m_Nv &#x3D; VertexNum;
	this-&gt;m_Ne &#x3D; 0;
	for (int i &#x3D; 0; i &lt; VertexNum; i++)
	{
		this-&gt;AdjList[i].FirstEdge &#x3D; nullptr;
		this-&gt;AdjList[i].m_Visit &#x3D; 0;
		this-&gt;AdjList[i].m_Kusal &#x3D; 0;
		this-&gt;AdjList[i].m_in &#x3D; 0;
		this-&gt;AdjList[i].m_Earliest &#x3D; 0;
		this-&gt;AdjList[i].m_Latest &#x3D; 0;
	}

}

void ALGraph::InsertEdge(int v1, int v2, int weight)
{
	EdgeNode* e &#x3D; new EdgeNode;
	e-&gt;m_Weight &#x3D; weight;
	e-&gt;m_CurNode &#x3D; v2;
	e-&gt;next &#x3D; this-&gt;AdjList[v1].FirstEdge;
	this-&gt;AdjList[v1].FirstEdge &#x3D; e;
	this-&gt;AdjList[v2].m_in &#x3D; this-&gt;AdjList[v2].m_in + 1;
	&#x2F;&#x2F;EdgeNode* e1 &#x3D; new EdgeNode;
	&#x2F;&#x2F;e1-&gt;m_Weight &#x3D; weight;
	&#x2F;&#x2F;e1-&gt;m_CurNode &#x3D; v1;
	&#x2F;&#x2F;e1-&gt;next &#x3D; this-&gt;AdjList[v2].FirstEdge;
	&#x2F;&#x2F;this-&gt;AdjList[v2].FirstEdge &#x3D; e1;

	&#x2F;&#x2F;this-&gt;m_Ne++;
}

void ALGraph::InputData(int Vertex, int data)
{
	AdjList[Vertex].m_Data &#x3D; data;
}

void ALGraph::ShowWeight(int v1, int v2)
{
	EdgeNode* e &#x3D; this-&gt;AdjList[v1].FirstEdge;

	while (e !&#x3D; nullptr)
	{
		if (e-&gt;m_CurNode &#x3D;&#x3D; v2)
		{
			cout &lt;&lt; v1 &lt;&lt; &quot; 相连 &quot; &lt;&lt; v2 &lt;&lt; &quot;  &quot; &lt;&lt; e-&gt;m_Weight &lt;&lt; endl;
			return;
		}
		e &#x3D; e-&gt;next;
	}
	cout &lt;&lt; &quot;没有相连&quot; &lt;&lt; endl;
}

void ALGraph::DFS(int Vertex)
{
	EdgeNode* e &#x3D; this-&gt;AdjList[Vertex].FirstEdge;
	int val &#x3D; Vertex;
	this-&gt;AdjList[Vertex].m_Visit &#x3D; true;
	cout &lt;&lt; this-&gt;AdjList[Vertex].m_Data &lt;&lt; &quot; &quot;;
	while(e !&#x3D; nullptr)
	{
		if (this-&gt;AdjList[e-&gt;m_CurNode].m_Visit &#x3D;&#x3D; false)
		{
			DFS(e-&gt;m_CurNode);
		}
		e &#x3D; e-&gt;next;
	}
}

void ALGraph::BFS(int Vertex)
{
	EdgeNode* e ;
	queue&lt;int&gt; q1;
	int temp;
	int val &#x3D; Vertex;
	this-&gt;AdjList[Vertex].m_Visit &#x3D; true;
	cout &lt;&lt; this-&gt;AdjList[Vertex].m_Data &lt;&lt; &quot; &quot;;
	q1.push(Vertex);
	while (!q1.empty())
	{
		temp &#x3D; q1.front();
		q1.pop();
		e &#x3D; this-&gt;AdjList[temp].FirstEdge;
		while (e !&#x3D; nullptr)
		{
			if (this-&gt;AdjList[e-&gt;m_CurNode].m_Visit &#x3D;&#x3D; false)
			{
				this-&gt;AdjList[e-&gt;m_CurNode].m_Visit &#x3D; true;
				cout &lt;&lt; this-&gt;AdjList[e-&gt;m_CurNode].m_Data &lt;&lt; &quot; &quot;;
					q1.push(e-&gt;m_CurNode);
			}
			e &#x3D; e-&gt;next;
		}
	}
}

void ALGraph::MinTree_Prim(int parent[MaxVertex])
{
	int lowcost[MaxVertex];
	lowcost[0] &#x3D; 0;
	parent[0] &#x3D; 0;
	for (int j &#x3D; 1; j &lt; this-&gt;m_Nv; j++)
	{
		lowcost[j] &#x3D; mINFINITY;
		parent[j] &#x3D; 0;
	}
	EdgeNode* e &#x3D; this-&gt;AdjList[0].FirstEdge;
	while (e !&#x3D; nullptr)
	{
		lowcost[e-&gt;m_CurNode] &#x3D; e-&gt;m_Weight;
		e &#x3D; e-&gt;next;
	}

	while (1)
	{
		int min &#x3D; mINFINITY;
		int temp;
		&#x2F;&#x2F;找到lowcost除了0之外的最小值
		for (int i &#x3D; 1; i &lt; this-&gt;m_Nv; i++)
		{
			if (lowcost[i] !&#x3D; 0 &amp;&amp; lowcost[i] &lt; min)
			{
				min &#x3D; lowcost[i];
				temp &#x3D; i;
			}
		}
		if (min &#x3D;&#x3D; mINFINITY)
			break;
		lowcost[temp] &#x3D; 0;
		cout &lt;&lt; parent[temp] &lt;&lt; &quot; &quot; &lt;&lt; temp &lt;&lt; endl;
		EdgeNode* e1 &#x3D; this-&gt;AdjList[temp].FirstEdge;
		while (e1 !&#x3D; nullptr)
		{
			if (e1-&gt;m_Weight &lt; lowcost[e1-&gt;m_CurNode])
			{
				lowcost[e1-&gt;m_CurNode] &#x3D; e1-&gt;m_Weight;
				parent[e1-&gt;m_CurNode] &#x3D; temp;
			}
			e1 &#x3D; e1-&gt;next;
		}
	}
}

void ALGraph::MinTree_Kruskal(int parent[MaxVertex])
{
	vector&lt; EdgeMaxtrix&gt; Edge(this-&gt;m_Ne);
	int k &#x3D; 0;
	int n, m;


	for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
	{
		EdgeNode* e &#x3D; this-&gt;AdjList[i].FirstEdge;
		this-&gt;AdjList[i].m_Kusal &#x3D; true;
		while (e !&#x3D; nullptr)
		{
			if (this-&gt;AdjList[e-&gt;m_CurNode].m_Kusal &#x3D;&#x3D; false)
			{
				Edge[k].m_Begin &#x3D; i;
				Edge[k].m_End &#x3D; e-&gt;m_CurNode;
				Edge[k].m_Weight &#x3D; e-&gt;m_Weight;
				k++;	
			}
			e &#x3D; e-&gt;next;
		}
	}

	sort(Edge.begin(), Edge.end(), compare);

	for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
		parent[i] &#x3D; 0;
	for (int i &#x3D; 0; i &lt; this-&gt;m_Ne; i++)
	{
		n &#x3D; Find(parent, Edge[i].m_Begin);
		m &#x3D; Find(parent, Edge[i].m_End);
		if (n !&#x3D; m)
		{
			parent[n] &#x3D; m;
			cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; Edge[i].m_Weight &lt;&lt; endl;
		}
	}
}

void ALGraph::GetNodeData(int Vertex)
{
	cout &lt;&lt; this-&gt;AdjList[Vertex].m_Data &lt;&lt; &quot; &quot;;
}

void ALGraph::GetInNode(int Vertex)
{
	cout &lt;&lt; this-&gt;AdjList[Vertex].m_in &lt;&lt; &quot; &quot;;
}

bool ALGraph::TopoSort()
{
	int temp,count &#x3D; 0;
	int k;
	EdgeNode* e;
	stack&lt;int&gt; s;
	for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
	{
		if (0 &#x3D;&#x3D; this-&gt;AdjList[i].m_in)
			s.push(i);
	}

	while (!s.empty())
	{
		temp &#x3D; s.top();
		s.pop();
		cout &lt;&lt; this-&gt;AdjList[temp].m_Data &lt;&lt; &quot; &quot;;
		count++;
		for (e &#x3D; this-&gt;AdjList[temp].FirstEdge; e !&#x3D; nullptr; e &#x3D; e-&gt;next)
		{
			k &#x3D; e-&gt;m_CurNode;
			this-&gt;AdjList[k].m_in--;
			if(!this-&gt;AdjList[k].m_in)
				s.push(k);
		}
	}

	if (count &lt; this-&gt;m_Nv)
	{
		cout &lt;&lt; &quot;有环&quot; &lt;&lt; endl;
		return false;
	}
	else
		return true;

}

bool ALGraph::TopoSortUseCriticalPath(stack&lt;int&gt;&amp; s2)
{
	int temp, count &#x3D; 0;
	int k;
	EdgeNode* e;
	stack&lt;int&gt; s1;

	for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
	{
		if (0 &#x3D;&#x3D; this-&gt;AdjList[i].m_in)&#x2F;&#x2F;把度为0的节点压栈
			s1.push(i);
	}

	while (!s1.empty())
	{
		temp &#x3D; s1.top();
		s1.pop();
		count++;
		s2.push(temp);
		for (e &#x3D; this-&gt;AdjList[temp].FirstEdge; e !&#x3D; nullptr; e &#x3D; e-&gt;next)
		{
			k &#x3D; e-&gt;m_CurNode;
			this-&gt;AdjList[k].m_in--;
			if (!this-&gt;AdjList[k].m_in)
				s1.push(k);
			if (this-&gt;AdjList[temp].m_Earliest + e-&gt;m_Weight &gt; this-&gt;AdjList[k].m_Earliest)
				this-&gt;AdjList[k].m_Earliest &#x3D; this-&gt;AdjList[temp].m_Earliest + e-&gt;m_Weight;
		}
	}

	if (count &lt; this-&gt;m_Nv)
	{
		cout &lt;&lt; &quot;有环&quot; &lt;&lt; endl;
		return false;
	}
	else
		return true;
}

void ALGraph::CriticalPath()
{
	EdgeNode* Node;
	stack&lt;int&gt; s;
	int ete;
	int lte;
	int temp;
	this-&gt;TopoSortUseCriticalPath(s);
	for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
	{
		this-&gt;AdjList[i].m_Latest &#x3D; this-&gt;AdjList[this-&gt;m_Nv - 1].m_Earliest;
	}

	&#x2F;&#x2F;计算latest time
	while (!s.empty())
	{
		temp &#x3D; s.top();
		s.pop();

		for (Node &#x3D; this-&gt;AdjList[temp].FirstEdge; Node !&#x3D; nullptr; Node &#x3D; Node-&gt;next)
		{
			if (this-&gt;AdjList[Node-&gt;m_CurNode].m_Latest - Node-&gt;m_Weight &lt; this-&gt;AdjList[temp].m_Latest)
				this-&gt;AdjList[temp].m_Latest &#x3D; this-&gt;AdjList[Node-&gt;m_CurNode].m_Latest - Node-&gt;m_Weight;
		}
	}

	for (int j &#x3D; 0; j &lt; this-&gt;m_Nv; j++)
	{
		for (Node &#x3D; this-&gt;AdjList[j].FirstEdge; Node !&#x3D; nullptr; Node &#x3D; Node-&gt;next)
		{
			ete &#x3D; this-&gt;AdjList[j].m_Earliest;
			lte &#x3D; this-&gt;AdjList[Node-&gt;m_CurNode].m_Latest - Node-&gt;m_Weight;
			if (ete &#x3D;&#x3D; lte)
			{
				cout &lt;&lt; j &lt;&lt; &quot; &quot;;
			}
		}
	}
	cout &lt;&lt; this-&gt;m_Nv - 1;
}

ALGraph::~ALGraph()
{
	EdgeNode* e;

	for (int i &#x3D; 0; i &lt; this-&gt;m_Nv; i++)
	{
		e &#x3D; this-&gt;AdjList[i].FirstEdge;
		while (e !&#x3D; nullptr)
		{
            this-&gt;AdjList[i].FirstEdge &#x3D; this-&gt;AdjList[i].FirstEdge-&gt;next;
			delete e;
			e &#x3D; this-&gt;AdjList[i].FirstEdge;
		}
	}
}

bool compare(EdgeMaxtrix E1, EdgeMaxtrix E2)
{
	return E1.m_Weight &lt; E2.m_Weight;
}

int Find(int* parent, int f)
{
	while (parent[f] &gt; 0)
		f &#x3D; parent[f];
	return f;
}




main文件
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
#include&lt;iostream&gt;
#include&quot;graph.h&quot;
using namespace std;


int main()
{
	ifstream ifs;
	ifs.open(&quot;yao.txt&quot;);
	int parent[MaxVertex];
	int VertexNum,EdgeNum,data;
	int Vertex1, Vertex2, Weight;
	ifs &gt;&gt; VertexNum &gt;&gt; EdgeNum;

	ALGraph A1(VertexNum);
	for (int i &#x3D; 0; i &lt; VertexNum; i++)
	{
		ifs &gt;&gt; data;
		A1.InputData(i, data);
	}
	for (int i &#x3D; 0; i &lt; EdgeNum; i++)
	{
		ifs &gt;&gt; Vertex1 &gt;&gt; Vertex2 &gt;&gt; Weight;
		A1.InsertEdge(Vertex1, Vertex2, Weight);
	}

	A1.CriticalPath();
	system(&quot;pause&quot;);
	return 0;
}


</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%8D%9A%E4%B8%BB%E5%9C%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%8C%E4%B8%BB%E8%A6%81%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%9C%89b%E7%AB%99%E4%B8%8A%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%EF%BC%8C%E8%BF%99%E4%B8%A4%E4%B8%AA%E7%94%A8%E6%9D%A5%E5%85%A5%E9%97%A8%E6%AF%94%E8%BE%83%E4%B8%8D%E9%94%99%EF%BC%8C%E4%BD%86%E4%BB%96%E4%BB%AC%E9%83%BD%E6%98%AF%E7%94%A8c%E8%AF%AD%E8%A8%80%E6%9D%A5%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%8D%9A%E4%B8%BB%E4%BD%BF%E7%94%A8c-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E8%BF%99%E4%B8%80%E5%A4%8D%E6%9D%82%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E7%AE%97%E6%B3%95%E3%80%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BD%BF%E7%94%A8%E4%BA%86%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E3%80%81%E9%82%BB%E6%8E%A5%E8%A1%A8%E4%BB%A5%E5%8F%8A%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84%EF%BC%8C%E5%88%86%E5%88%AB%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8A%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E4%B8%89%E7%A7%8D%E5%BA%94%E7%94%A8%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%BD%BF%E7%94%A8%E4%BA%86Prim%E7%AE%97%E6%B3%95%E3%80%81Kruskal%E7%AE%97%E6%B3%95%EF%BC%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BD%BF%E7%94%A8%E4%BA%86Dijkstra%E7%AE%97%E6%B3%95%E3%80%81Floyd%E7%AE%97%E6%B3%95%EF%BC%8C%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E4%BD%BF%E7%94%A8%E4%BA%86%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%BA%94%E7%94%A8%E3%80%82%E4%BB%A5%E4%B8%8B%E6%98%AF%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.0.0.0.1.</span> <span class="toc-text">最近博主在学习数据结构和算法，主要的学习资料有b站上浙江大学课程数据结构和算法以及《大话数据结构》，这两个用来入门比较不错，但他们都是用c语言来实现，因此博主使用c++来实现图这一复杂结构以及对应的算法。存储结构使用了邻接矩阵、邻接表以及边集数组，分别实现了最小生成树、最短路径以及有向无环图三种应用，其中最小生成树使用了Prim算法、Kruskal算法，最短路径使用了Dijkstra算法、Floyd算法，有向无环图使用了拓扑排序以及关键路径的两种应用。以下是代码：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95--%E5%9B%BE/" title="数据结构和算法---图（C++）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构和算法---图（C++）"/></a><div class="content"><a class="title" href="/2022/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95--%E5%9B%BE/" title="数据结构和算法---图（C++）">数据结构和算法---图（C++）</a><time datetime="2022-04-07T16:00:00.000Z" title="发表于 2022-04-08 00:00:00">2022-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/09/%E8%96%84%E8%86%9C%E9%BB%8F%E9%99%84%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%89%E9%99%90%E5%85%83%E6%96%B9%E6%B3%95/" title="薄膜黏附问题的有限元方法"><img src="http://www.imech.cas.cn/xwdt/kydt/201909/W020190905572469035373.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="薄膜黏附问题的有限元方法"/></a><div class="content"><a class="title" href="/2022/03/09/%E8%96%84%E8%86%9C%E9%BB%8F%E9%99%84%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%89%E9%99%90%E5%85%83%E6%96%B9%E6%B3%95/" title="薄膜黏附问题的有限元方法">薄膜黏附问题的有限元方法</a><time datetime="2022-03-08T16:00:00.000Z" title="发表于 2022-03-09 00:00:00">2022-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/%E8%A2%AB%E5%AD%90%E7%9A%84%E8%A4%B6%E7%9A%B1%E5%88%86%E6%9E%90/" title="abaqus褶皱分析"><img src="https://img.yipic.cn/thumb/403a4b3e/83314ad7/4460e54b/193445f2/big_403a4b3e83314ad74460e54b193445f2.jpg?x-oss-process=image/format,webp/sharpen,100" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="abaqus褶皱分析"/></a><div class="content"><a class="title" href="/2022/03/01/%E8%A2%AB%E5%AD%90%E7%9A%84%E8%A4%B6%E7%9A%B1%E5%88%86%E6%9E%90/" title="abaqus褶皱分析">abaqus褶皱分析</a><time datetime="2022-02-28T16:00:00.000Z" title="发表于 2022-03-01 00:00:00">2022-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/19/ABAQUS%E5%AD%90%E7%A8%8B%E5%BA%8Fvuinter(2)/" title="ABAQUS子程序-vuinter(2)"><img src="http://feaassist.uk/wp-content/uploads/2020/07/Methods-44-1024x940.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ABAQUS子程序-vuinter(2)"/></a><div class="content"><a class="title" href="/2022/02/19/ABAQUS%E5%AD%90%E7%A8%8B%E5%BA%8Fvuinter(2)/" title="ABAQUS子程序-vuinter(2)">ABAQUS子程序-vuinter(2)</a><time datetime="2022-02-18T16:00:00.000Z" title="发表于 2022-02-19 00:00:00">2022-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/19/%E9%A1%B9%E7%9B%AE%E5%92%8C%E8%AF%BE%E9%A2%98/" title="项目和课题"><img src="https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/f9198618367adab486a46fcb8ad4b31c8601e4c6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目和课题"/></a><div class="content"><a class="title" href="/2022/02/19/%E9%A1%B9%E7%9B%AE%E5%92%8C%E8%AF%BE%E9%A2%98/" title="项目和课题">项目和课题</a><time datetime="2022-02-18T16:00:00.000Z" title="发表于 2022-02-19 00:00:00">2022-02-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Eren</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>